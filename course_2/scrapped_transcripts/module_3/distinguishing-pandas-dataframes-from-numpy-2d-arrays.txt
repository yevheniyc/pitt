Source: https://www.coursera.org/learn/the-art-of-data-visualization/lecture/O0C0H/distinguishing-pandas-dataframes-from-numpy-2d-arrays

English
Now besides the data type itself being different,
our first clue that there's
something different about xdf compared to
x is when we print
the DataFrame compared to printing the 2D array,
the 2D array has brackets
everywhere to let us identify the rows,
but there are no brackets with the DataFrame.
Instead, we see this 0-5 on the left,
and this 0-5 on the top,
and then this blank spot on the very top left.
But when I am working with DataFrames,
I almost never print them.
Instead, I just display them.
I prefer this approach compared to print.
Even though a lot of
Python users really like to print objects,
I prefer to display it because we get actually
an easier-to-read display of the data.
In fact, it looks like a spreadsheet.
The leftmost set of numbers are boldface font.
These are not the values in the DataFrame,
they are the index attribute,
just like the index attribute from a series.
The top row of numbers that we looked
at previously are also boldface font,
and we'll return to those shortly.
The top left corner is empty,
there's actually nothing here.
But then look at my cursor.
Do you see every time I place it on one of the rows,
how it highlights the row in that table?
You see which row I'm focusing on?
We don't get anything like that with the print.
We also have the alternating gray-white rows
to just help our eyes.
Our first clue that
the DataFrame is something different from
the numpy 2D array
is just the way the object is displayed.
We are really trying to highlight that
this is something that looks like a spreadsheet.
It's something that looks like a table.
But here's then the other reason,
or another way we can see
that numpy 2D arrays
and panda's DataFrames are different.
Provide a single index into or
provide a single index to slice the numpy 2D array.
We know x0 gives us the zeros row.
Look what happens when we use
a single index to slice the DataFrame.
Xdf, square brackets, zero.
We do not get the same result as the numpy 2D array.
Instead of seeing 1, 2, 3,
4 values displayed, we instead see 1,
2, 3, 4, 5, 6.
If you look closely,
what we're getting is the zeros column here.
In numpy, to get all rows from the zeros column,
we need to use the two indices;
the row and the column indices.
But if we do the same thing with our DataFrame,
we get an error.
If we would instead try and
identify or select all columns from the zeros row,
we also get an error.
The numpy way of identifying or slicing,
it isn't working the same way.
What this means is there is clearly something different
about the pandas DataFrame
compared to the numpy 2D array,
even though both are table-like,
both have two dimensions,
both have rows and columns.
But we cannot interact with
a pandas DataFrame using
syntax just like the numpy 2D array.
Things are, in fact, different.
The hint for why they're different has to do
with what we learned with the pandas series.
Remember, the Pandas series is
like a list dictionary and one numpy array.
It's really borrowing ideas from all three of them.