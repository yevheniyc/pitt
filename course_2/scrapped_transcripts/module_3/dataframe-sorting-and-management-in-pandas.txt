Source: https://www.coursera.org/learn/the-art-of-data-visualization/lecture/J9iq5/dataframe-sorting-and-management-in-pandas

English
Sometimes when you sort and thus change the row order,
sometimes we do not want to
retain the original index attribute positions.
Meaning, now that I have sorted,
I want the index of the top row to be zero,
and I want the index of
the last row to be the appropriate last index.
Therefore, we want to
ignore the index when we sort.
I use that term ignore very
specifically because the argument
is ignore_index, true.
Now, the returned zero index is
the top row and the returned last row is four,
rather than getting the seemingly random index
as we got previously,
even though we know this is not random
and we sorted by team.
We could also sort
in descending order, baseball_df.sort_values[Team].
Let's ignore the index again,
and then the argument is ascending.
By default, ascending is true.
But if we set ascending to false,
now the top row will be
the last value of the column we are sorting by,
and the last row will be
the starting value that we're sorting by.
The result is not stored,
so to store or keep the sorting,
we need to either assign to
a new object such as baseball df,
and I'll name this one, _b, baseball_df.sort_values.
Here, let's do sort by team.
We'll ignore the index.
True, we'll put into descending order.
But just to be safe,
I'm including a deep copy.
When I assign a result to a new object,
I like to force the deep copy.
We learned about the dot copy method with NumPy.
This will break any dependency
between the original object and the new object.
I personally like to enforce the deep copy,
that way we never get
any strange dependencies impacting our results.
Remember how we learned
that if you do
not force the deep copy and you have the shallow copy,
changing something in the new object
can impact values in the old.
I never like to deal with that because I find it to
be incredibly inconvenient and annoying,
so I force the hard copy, the deep copy.
Alternatively, we can force Pandas to
modify in place using the in place argument.
baseball_df.sort values. Now this time I won't do
anything with the index and I will
keep ascending as it's default true,
but I'll say in place equals true.
Let's now look at baseball_df.
Baseball_df, because I said modify in place,
the Brewers are now located up at the top.
But look at the index, we have four.
We have four up at the top because I did not ignore it.
Also, the Brewers are at the top because
I allowed it to stay in ascending order.
Now my baseball_df and my baseball_df_b
actually store different dataframes
because of the hard copy.
Let's summarize. In summary,
this video focused on creating
dataframes from NumPy and from dictionaries.
This was to highlight the fact that
data frames are 2D objects;
they have two dimensions,
so rows and columns.
This was to highlight that
the KEY becomes the column name.
We need to think of
Panda's dataframes as a combination of
the NumPy 2D array and the Python dictionary.
That was really the primary focus of this video.
There are some things that have been introduced that we
have not covered just yet, for example,
how do we actually go about
selecting columns and rows in Panda's dataframes?
Well, that's something that we will
see in the next video.