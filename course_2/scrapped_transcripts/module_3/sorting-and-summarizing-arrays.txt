Source: https://www.coursera.org/learn/the-art-of-data-visualization/lecture/R1pMO/sorting-and-summarizing-arrays

English
So let's first type this in again, np concatenate,
a_array, a, b, b_array.
This is an array,
meaning it has the n dim attribute,
meaning it has the shape attribute,
meaning it has the size attribute.
Whenever you concatenate or combine arrays together,
I really recommend checking these attributes
so that you know how big your new array is.
Let's assign the result
of the concatenation to a new object,
and I'm going to name this object big array,
a_array, a, b, b_array.
Yes, it's an array.
Again, we have all the same attributes.
Whether we are working with the result
directly or we assign it to a new object,
a new variable that's in the memory,
we have access to it.
Big_array, 33 elements.
Next, change element order by sorting.
There are multiple ways to change
the element ordering but let's see the dark sword method.
NumPy Arrays, we have
seen several of the important attributes.
But NumPy Arrays have
many different methods and a method is
a function associated with a particular data type.
The sort method will
change the order of the values in the array.
Look closely here, big_array.
Big array has a value -1,
big array has a value of 101.
When we sort the values,
the smallest value will go to
the beginning and the largest value will go to the end.
Sort therefore, orders in ascending order.
To apply it, you use the period
or dot notation and you type sort.
Since it's a method,
you need the parentheses.
Now, sort modifies in place,
so I don't need to assign the result to a variable.
It looks a little odd at first,
but you're really applying
this function to this object and it changes it.
It does not change the number of dimensions,
does not change the number of elements in the dimensions,
it does not change the overall size.
But as you can see,
it has changed the ordering.
Now 101 is the first,
the zeroth element,
then the rest of the negatives,
- 101 is the first,
and then +101 is the last.
We can order with
the largest values before the smaller values.
This is known as descending order,
but descending order is not
straightforward and the sort method from NumPy,
we will learn a much easier
descending order approach with pandas.
The last manipulation strategy
that we will discuss is summarized.
Summarizing values in an array returns fewer values.
We have already seen several important summary functions,
such as summing, calculating the average of the mean,
calculating the variance, and the standard deviation.
However, we needed to define
functions to execute those tasks in base Python.
NumPy is much easier for
summarizing the base Python but we must be careful.
Now the summary functions are methods.
That means if we want to apply a function,
we can use the dot notation
to apply that method to the object.
For example, the sum method
sums all the values in the array.
But as you can see here,
the original array is not modified.
We are summarizing it.
We are summing all of its values,
all the values contained in the array.
But the original array is still
present in memory, that's really important.
You can see big_array, it's still here.
The reason why the summary functions,
the summary methods do not modify in
place is because there are
many different summary functions we
can do where we can calculate.
We can calculate the min and max values in the array
, big_array.mean, big_array.max.
The average is calculated with the.mean method.
A very important method, big_array.mean.
As a quick reminder,
remember the average is supposed to be near the center.
If we return to our very simple array
a and we apply mean,
we're pretty close to the center.
If we turn to the array b,
the average is literally zero in the direct center.
If we go back to the larger array,
remember we have a mix of numbers less than zero,
we have a mix of numbers greater than zero.
The mean is close to zero.
Again the main point, the mean
represents something in the center.
NumPy also has a method for the variance.
We don't need to write our own function, big_array.var.
We can of course apply variance to
all the other arrays that we have made here.
There is also a method for
the standard deviation, big_array.std.
As a reminder, the standard deviation is
the square root of the variance.
If we raise the variance to the one half power,
we recover the standard deviation.
Or if we square the standard deviation,
we recover the variance.
That's just as a little reminder.
But what this means is
if you want the standard deviation,
just use the standard deviation method.
You don't have to take
the square root of it like we had to do in base Python.