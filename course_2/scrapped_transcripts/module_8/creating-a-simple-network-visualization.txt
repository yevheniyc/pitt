Source: https://www.coursera.org/learn/the-art-of-data-visualization/lecture/uZx2x/creating-a-simple-network-visualization

English (auto)
In this lesson, we are going to look at how we can use
NetworkX to do a simple network visualization.
Here is an example of how we can create a simple graph.
We're going to go over this code in
different parts of it to understand how the code works.
The first part, as you can see,
you import the libraries.
This is similar to anything we've been doing in Python,
and specifically for the NetworkX,
you're going to be importing that library
and associating an object with that.
Then you can initialize an instance of an undirected graph,
which is stored in that variable g,
using basically this function of a graph,
which as we talked about,
this is going to be assuming that this is an undirected graph.
If you want this to be a directed graph,
you can use diGraph instead of graph.
Then once you have initialized,
your general graph object,
then you can start adding nodes and edges to that by using
the functions addNode or addNodes from a list of nodes,
similarly to addEdge between the two nodes
or adding edges from a particular list that you provide.
In the next lesson,
you're going to also look at how we can actually,
instead of defining nodes and edges ourselves manually this way,
how we can use to import files to create the network.
Once then we have defined the network,
we can basically visualize the network and show the visualization.
This is in a plot similar to
other visualization that you have seen in previous lessons as well.
Just this is from the matplotlib,
and you're then just showing the plot.
This also works if you're using the Jupyter Notebook.
Now let's look at the visualization of the graph,
the code step-by-step.
This is the line of the code that creates the network visualization.
Main function is a function of draw,
which it draws the graph G that we had created earlier using NetworkX functions.
Then the function uses a default layout,
which usually is a spring layout.
A spring layout is the same as the first directed layout that we saw in
the last module as well to position the nodes and edges.
You can actually specify if you don't want to use
a default layout and you want to have other layouts,
you can specify those different layouts,
for example, a SQL layout or a shell layout.
You're going to see examples of how you can use these as well.
The next parameter in this function is providing
a label for the nodes whether these labels,
we want to have them be shown or not,
so that variable could be set into true or false.
The purpose is to display the labels that identifies the nodes,
and without specifying these,
the nodes would be visualized as unlabeled,
so that's the default setting.
The next parameter provides the node color,
and you can provide colors in different formats of
hexadecimal or an array of colors for individual node customization.
You can also specify the node size.
The size is specified in points where a larger value makes the nodes appear bigger,
and these node size also can actually come from different measure.
It doesn't need to be a constant variable,
it could actually be different for different nodes,
and you will see, for example,
you can use some of the metrics and measurements of
the network as a way of representing node sizes
to visualize the importance of a node as well.
The next one is basically the size of the font used for the node labels,
that affects just the readability of the labels,
especially for larger, more complex graphs.
We can also use the node and edge attributes as we are creating the graphs,
and visualizing the graph,
the node attributes are useful for storing metadata about the nodes.
For example, in a social network,
nodes can represent people and their attributes can
represent characteristics such as age,
the role of that node, or gender.
The edge attributes are useful for storing
metadata about their relationships or connections,
and example of that would be in a social network,
edges can have attributes such as
interaction frequency or type of the relationship.
Here is how you can have attributes added to nodes and edges,
and how you can access those.
You can just provide the specific node and add
that custom attribute of role here and the value of that,
in this case, which is a leader.
Similarly, you're adding here by specifying
the connection between node A and B,
and then the next parameter specifies
the particular attribute for that edge and the value of that.
Then if you want to access that,
you basically just access it as in the data structure that you have created,
so the role would denote a role attribute and similarity for the edge.
We can use NetworkX to analyze a network as well,
using measures we learned in the prior module.
For example, you can calculate degree centrality using
the function degree centrality will
generate the degree search for all the nodes in the graph,
or you can create the shortest path,
identify and show the shortest path between the specific nodes,
or you can actually have it for the entire graph as well.
In the example here,
you're looking at the shortest path between two specific nodes,
but if you don't specify the nodes,
it actually shows the shortest path for all of
the different node combination within the graph as well.
You can define your graph to be a directed graph,
as I mentioned earlier,
by using the DI graph,
and then you're adding the edges that these are going to be then directed.
So this basically assumes that A is the source and B is the target.
Here B is a source and C is the target.
You then visualize a network similar to what we did earlier here.
You can also add the arrow style how you want the direction
of those to be shown because this is a directed graph.