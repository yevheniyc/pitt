Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/iiNyP/chaining-multiple-joins-and-writing-dataframes-to-csv-files

English
The merge method allows us to chain
together multiple joins in a single line of code.
What do I mean by that?
Let's join dfA with dfB.
That result to dfC.
Pd.merge dfA is the left,
dfB is the right.
This join will be joined on
E. Now I want to use the left join.
We will join that result or merge that result with
dfC on F using a right join.
This chain, if you will,
is giving me the most amount of missings.
I know it's a little hard to see,
but you can see when E is CC,
that's when we get the missings for G A through E and
G have missing values for
the two values of F not present in dfA.
I am choosing to do this very specific join,
a left join between dfA and dfB,
and a right join between that and dfC,
because for this example,
I'm trying to actually maximize the number of missings,
even though Pandas, by default,
likes to use inner to
produce a minimum number of missings.
Let me make a note of that. I am, on purpose,
trying to generate the maximum amount of missings.
The inner join used by Pandas by
default tries to minimize missings.
Now, which one should do you use?
It usually unfortunately depends.
A lot of times
people want to get rid of missings and that's
why the inner join is the default in Pandas.
I personally like to retain
as much as I possibly can
and then go about dealing with the missings.
It helps me understand the data a little better,
but again, that's my personal style.
Let's assign the result of this join to a new variable.
I'm going to assign
the df object to the result of pd.merge dfA,
dfB on E how equals left,
and merge that to dfC on F how equals right.
Again, we get the maximum amount of missings here.
Since this is in fact a data frame,
we could do operations like
sorting based on how about B,
because B, you can see is out of order.
Let's modify in place and ignore the index.
We now have the same row ordering as originally for dfB.
At this point, we could do whatever we want.
Oftentimes, you need to join
data together before you can explore it.
The goal or reasoning for joining data is to allow
us to study the relationships
between many more variables.
I am now able to study what's going on between H and G. I
couldn't have done that with the way the data
were originally stored in three separate files.
We can go about exploring
the data which we have not talked about yet,
that's what the remainder
of the class is really going to be getting into.
But I'm just showing you a couple methods that will help.
But for our purposes right now,
the main thing that I want to show
is how to write to a file.
We created a joined dataset.
Let's save that joined dataset to a CSV file.
To do that, we start with
the Pandas data frame and we use the to method.
There's a whole lot of different to methods,
but the one we will use right now is to_CSV.
The main argument is the new file you're about to create.
I'm going to name this joined_data.csv.
If I open up my File Explorer,
you can see I don't have a file with this name just yet.
That's perfectly okay.
We're making that new object right now.
Now if I check my fold my file, easyjoined_data.csv.
If we import os,
os.list directory, joined_data.csv,
it's now located right here.
Let's check everything is the same
by reading in the written data.
I'm going to name this df again.
It's giving the result of pd.read_csv joined data.
Now if you notice,
something doesn't look right.
See unnamed:0.
Unfortunately, by default,
the to_CSV method
writes the index attribute.
But the CSV file does not know
that the index attribute is something special.
It does not know that the index is not a column.
For those reasons, I like to set index to false.
I don't like to have the index column written.
This is a property of Pandas,
it's not necessarily a property of the CSV file.
I personally like to do index equals false.
Let's go back and rerun it.
If we check the directory,
that file is still there.
If we load it in again,
now you can see we no longer
have those issues with that weird column.
This is the exact same object that
we created here through the joins.
Again, the main purpose of
this recording was to introduce you to joins.
They are very important to get practice
with and very important to understand how they operate.
The secondary goal of this was to show you how to
write a data frame to a CSV file.
That way we can load it back in.
Because the remainder of the examples for
this week require you to work with this joined dataset,
so you need to
write this file in order to use it going forward.