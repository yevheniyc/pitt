Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/HOBpZ/column-data-types-and-setting-the-row-index

English
Before we continue, let's do this one more time.
But this time we will assign the result to an object,
to a variable I'll name df0.
If we check the environment,
df0 is a data frame.
If we use one of the methods we learned about last time,
df0.info, there are six columns,
A, B, C, D, E, F,
there are 12 rows,
three of the columns are integer numbers,
and three of the columns are objects or strings.
If we look at the data in Excel,
that's exactly what we see.
Here is one that's a string, the A column,
the D column is another string,
and the E column is another string.
Of course, we could have got
that information from using the shape attribute,
using the column names attribute,
and the D types attribute.
If we check the index and it's a range index.
Now by default, the read Excel function
thinks none of the columns in
this table are the index attribute.
However, we can force one of the columns to
be the index attribute when the data are read.
For example, I wish to specify
the zero column as the index attribute.
To do that, let's assign it to a new object, df0_b,
pd.read_excel, type the file name.
You can see it, I'm typing this very fast
because I'm using tag complete.
But to set the index column,
we need to use the index_col argument.
What column position corresponds to the index?
Now, the data as read in looks different.
The actual information, of course, is the same.
But the attributes or properties of
the data are very different than they were before.
Pandas views it as there's only five columns.
That's because the index
is the A column from the Excel spreadsheet.
If I want to find one of the rows in the data frame,
I can use the index location key
to get all of the columns for that row.
If I use a different location key,
we get a different row from the table.
Again, to highlight this.
Pandas actually views it as
there's less columns because one of
the columns has really been
absorbed or viewed as the index attribute.
I personally dislike this.
As I mentioned before,
I want my variables to be actual columns,
not a hidden column.
I want them all to be treated the same.
But I'm just trying to show you this how
you can read it in differently if you would like.
We do not just need zeroeth column to be the attribute,
it can be any column.
Let's read it in again,
you use that pd.read_excel
function but now set the index column to be four.
The index attribute is now the E column.
Again, five columns.
E is not one of them,
or the E column in Excel is now the attribute.
If we use the loc method or sorry,
loc attribute and I identify
all rows based on the index location key.
Here, everything that has index aa is returned.
Now, as I mentioned earlier,
by default, none of the columns are treated as the index.
The default argument is read_excel,
type in the file name,
index col equals none.
Now we have all six columns available to us.
Again, the index attribute is
just created to be a range index.
Let's now pay special attention to
the headers or the column names.
Because by default,
the pd.read family of
functions assumes the top row
is the header row,
the top row therefore does not contain values.
Instead, it is assumed
the top row or header row contains the column names.
If we go back to the first time we read in the function,
those columns, again,
their names came from that top or header row.
Even though that header row
provided characters or strings,
the values beneath it could be numbers.