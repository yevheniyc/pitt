Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/O8YBy/handling-headerless-excel-sheets

English
Let's see what happens if we work with a dataset or
a sheet within an Excel workbook
that does not use a header row.
Let's pull up the Excel workbook again.
The second sheet,
I've renamed to no headers.
The top row has been removed,
we only have the values now.
When you know there is no header,
then the header argument must be set to none.
I'm going to read in the data again,
going to assign it to the object df0 no names,
calling it the read Excel function.
I'm reading in from the same file,
but now I need to make two changes.
First, I need to specify the no headers sheet.
I don't want to read Sheet 1.
If you were paying attention,
every time I was calling this function before,
I didn't even mention the sheet.
That's because by default,
read Excel reads the very first sheet
in the Excel workbook.
But we can change that with
the sheet name argument and now I
can type in the name of the sheet, no headers.
Lastly, header equals none because we know
that there is no header row,
and so we get the same set of data.
We get all 12 rows for all six columns,
but we just get default column names which
are zero through five.
You get numbers, which I really dislike.
I wish they would put an X or V by default,
but that's what they do.
If there is no header row,
we can use the names argument to name the columns,
so df0 no names 2, pd read Excel.
Here's the file that we're going to read in.
We're going to read everything from
the sheet, no headers.
The header equals none.
But now, rather than just manually typing this,
I'm going to use the columns attribute from df0.
We now get the correct names for all six columns.
It's really the names argument
that's now giving us the column names that we want.
But be very careful if there is
a header row and you specify that there isn't by mistake.
What I'm going to do now is I'm going to read
in the same Excel file,
but I'm not going to specify the sheet.
Thus, by default, the first sheet is
read in which we know has the headers.
But I will, by mistake,
set header equal to none.
That's why I'm naming the object df0 mistake.
If we check the shape,
we no longer have 12 rows, we have 13.
If we check the info,
the column names or numbers now,
and look at the data type,
there are 13 entries and
every single column is object or string.
By mistakenly saying there was no header row,
the variable or column names become
the top row or the zero row in the data frame.
This can happen, it's a mistake.
You think there's no header
and you specify header equals none,
and you read in data.
This is part of the reason why checking
the data types is so important when you are
initially exploring a dataset
because if you are expecting to see
numbers and you don't
get any numbers at all in the dataset,
in the data frame, that
could be because you messed up the header.
The header is being read in as the zero row,
the data, you're losing the actual names.
You need to just go in and double
check what you specify for the header argument.
To wrap up this example,
we can read other sheets,
just specify the sheet name argument appropriately.
For example, ExB and ExC,
I won't assign these to objects.
I'll just call the function,
Excel sheet name ExB.
Exactly what we saw in Excel for ExB,
three rows, two columns,
and then the same style of thing for Excel.
There we go, sheet name,
ExC, four rows and two columns,
exactly as we see.