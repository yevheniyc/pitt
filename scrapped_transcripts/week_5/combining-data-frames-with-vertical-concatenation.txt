Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/ih6lO/combining-data-frames-with-vertical-concatenation

English
Hello everyone. In this video we're going to
discuss combining data frames through concatenation.
I already have my Jupyter Notebook opened up,
and I will create
a new Jupyter Notebook kernel here, Python kernel.
If you haven't done so, please navigate
to your working directory and
open up a Jupyter notebook there.
Let's go ahead and now change the file name,
week_05_combine_concat.
Then set in some headers.
Combined data frames concatenation.
Let's import modules.
Again, the exact same modules we've worked with in
the other recordings for this week, NumPy and Pandas.
In the previous video,
we learned about how to read in data.
Let's read in the example A,
CSV file discussed in the previous recording.
I'm going to name the object we
assign the data to, to dfA0.
As we saw in the previous recording, pd.read_csv.
Give it the file name.
We won't specify any other argument because we saw that
the top row is
the header row and there is no index column saved.
There is no index column in
the CSV file so we want the default range index created.
But now I want you to add
a column with a constant value of zero.
I want you to do this for a reason
that will make more sense here in a minute.
But let's name this new column attempt.
It's zero down all rows.
Now, read in the same CSV file again.
But this time we will assign it to dfA1.
Gets assigned pd.read_csv example A.
It's the exact same data.
Add a constant, but this time equal
to 1. dfA1 attempt equals 1.
We now have two data frames, dfA0, dfA1.
We learned that with NumPy,
we can vertically concatenate two arrays together.
Vertically combining means we
stack the objects on top of each other.
You could do something very similar with Pandas.
The function is pd.concat.
It has an input argument very similar to what we learned
about with Vstack in concat from NumPy.
We need a list,
and the elements in the list are the
now data frames we wish to concatenate.
If you wondered why I added this column attempt,
it's because it makes it very easy for us to find
out what was the zeros data frame we
read in versus the one data frame
we read in after we combined them.
Literally the two data frames
were just stacked on top of each other.
They have the same headers and
so there is no second header row appearing.
It's like the values
themselves are stacked on top of each other.
This works because both data frames
have the same column names.
This can be confirmed by
comparing each of the column names. They're all true.
But look closely at the index attribute of
the combined vertically stacked data frames.
Zero through 11, zero through 11.
Or if we repeat
the action and then
check the location key for an index,
you can see it's repeating.
We are able to pull out rows
from the two different data frames
from the exact same index.
By default, the index attribute is allowed to repeat.
The index does not
uniquely define a row in the new stacked data frame.
Ignoring the index allows each stack row to be unique.
If we do pd.concat, dfA0,
dfA1, ignore_index true,
now you can see the index no longer repeats,
it just keeps going.
It's now the index for this stacked data frame.
Something else that I like to do,
I also like to force the deep copy as a just in case.
pd.concat, dfA0,
dfA1, ignore_index true copy true.
We can assign the result to an object, of course.
Let's name it dfA_double,
pd.concat, dfA0,
dfA1, ignore_index,
true, copy equals true.
As a reminder, what's changing with
vertical concatenation is the number of rows.
That's what's changing.
Vertically stacking does not change
the number of columns or it is
not intended to change the number of columns.
You're adding data together,
so you should get more rows.