Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/OYRii/constructing-a-heatmap

English
The counts for the combinations can be
visualized through the sns.heatmap function.
This is an axes level function that once
the data organized in the style of pd.crosstab.
sns.heatmap once the data organized this particular way.
Since it is an axis level function,
we need to define the figure and axis object,
plt.subplots(), sns.heatmap.
But now, instead of using data = penguins,
let's just specify the result of the cross-tabulation,
(penguins species, penguins.island,
ax =ax), plt.show.
We now have a graphic, a image,
a plot that is organized
similarly to our cros-tabulation.
The color corresponds to the count,
the color of the tiles.
You see this bright yellow color?
That has the highest count,
whereas the dark color,
these are tiles with the lowest count.
What I particularly like about
sns.heatmap is that it is easy to annotate.
Annotate means include text,
so we can read the number and see the color.
Let's make it again,
fig, ax = plt.subplots(),
sns.heatmap(pd.crosstab(penguins.species,
penguins.island), ax = ax.
But now let's also include annotate, annot=True.
By default, we get some text for the count,
and now it's really easy to see the 0 counts.
If the font size is too small,
use the annotate_kws argument to change it.
Kws stands for keywords.
This is a dictionary.
Why did we learn about working with dictionaries earlier?
Dictionaries are essential ways of providing
more complex arguments to
our advanced functions for data analysis.
Annotate, annot_keywords.
The dictionary has a key value pair size,
and the value is the size of the font.
Here, I'm using 30 to make very large font.
If I change it to 20, it's
still pretty big but a little smaller.
Now, this number here,
you see the e. This is scientific notation,
but I don't want scientific notation.
Instead, I can use the fmt argument,
this stands for format.
If I type 'd' as a string,
this stands for integer.
Give me the integer number.
Now we just see the 124 printed.
Since I have the count annotated per cell,
I like to turn off the color bar to give me
a little extra room since
the color and the text are now just redundant.
If you look closely, the color of
the font is actually changing based on the background,
so it's always easy to read.
The one downside of heat map being
a axis level function is
that it's difficult to facet, but that's okay.
It's really useful and handy for creating
the combinations between two categorical variables.
For example, to get the sex in let's say,
have island fig,
ax = plt.subplots(),
sns.heatmap(pd.crosstab,( penguins.island,
penguins.sex), ax =ax).
Now let's modify it,
annotate = True,
annotate_keywords={'size': 20}.
That's fine, cbar=False.
Now we know the number of males and females per island.
Again, this was all being shown to us through
the faceted bar charts and the dodged bar charts.
But heat maps are particularly good at letting us see
which combinations are not
present because we get the literal 0s.
If you really want to show which combinations
are not there in your dataset, use a heat map.
Bar charts are easy for us to
see which combinations have the highest counts.
But we can get a little lost about which combinations are
not present because we have
to knowingly say, you know what?
I don't see all the colors here.
The heat maps take care of that
for us by giving us the 0s.
In summary, combinations are really about
relationships between categorical variables.
We can build off of the bar chart to look at
those combinations or use the heat map,
which is a tile to represent the combinations.