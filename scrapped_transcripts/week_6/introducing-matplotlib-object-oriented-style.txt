Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/pv5L5/introducing-matplotlib-object-oriented-style

English
If this looks like it's very compressed,
that's because the overall size is based on
the figure window or the figure image size.
We can control the figure size with
the figsize argument to the plt.figure function.
Let me paste this again.
Five and 5. Again,
we'll populate on 5.
But now, instead of using the default,
which is exactly what we ran before,
let's now say figsize = (12, 8).
If we would instead do (12,
4) let me run it again.
The second number or the one position in Python terms,
the one position controls
the vertical size of the figure.
The larger this number is,
the taller the figure is.
The smaller the number is,
the shorter the figure.
The zero position is the width of the figure.
The shorter the number, the less wide.
The larger the number,
the wider it becomes.
I typically like to use 12 and
6 or 12 and 8 as my figure size,
but these two have to change depending on the situation.
That's really an introduction to the stateful style.
Let's now see the second approach,
the object oriented style.
Many aspects of the object oriented style figures
are the same as the stateful figures.
But the way we access
or apply functions to them are different.
For Step 1,
instead of initiating the figure,
we instead define the figure and axes objects.
We literally create variables for the figure and axes.
Step 2, block the data within the axes,
using methods associated with the axes objects.
Step 3, modify the axes objects attributes if needed.
Step 4, modify the figure object attributes if needed.
Then Step 5, show the figure.
The commonalities, yes, you will need to show the figure.
Yes, you need to initialize something.
Yes, you need to state the axes or subplot that
contains the data and
you need to populate that data or plot it.
But again, the way this is done is different.
The motivation for the object oriented approach
is that the stateful approach works with hidden objects.
I really dislike the hidden object style.
I think I've mentioned this before,
but I programmed in MATLAB for a very long time.
Well over a decade.
I am an expert MATLAB programmer,
but I no longer like the MATLAB style,
even though I did it for a very long time.
The fact that there's these hidden objects that you're
interacting with behind the scenes, it's very strange.
It leads to a lot of weird and strange behaviors,
strange errors that seem to pop up from time to time.
This is something where the object
oriented style does really,
really help because we will define variables
or objects for the figure and axes that we are modifying.
But the common names for these objects are fig and ax.
There were a few different ways to create these objects,
but I personally like to use the plt.subplots function.
Notice very carefully here what's going on.
I'm not calling plt.subplot, I'm calling plt.subplots.
Plural with an S. To the left of the equals operator,
we're using the multi-assignment, fig, ax.
We are creating two new objects.
Before I run this line of code,
I'm going to call the who is magic command to show you
we only have in memory that we
can literally see the three modules.
But now when I run this line,
fig, ax = plt.subplots.
Yes, something is displayed.
The figure containing the axes,
the horizontal and vertical coordinates are displayed.
But even more importantly,
if we check the environment,
we now see there are
two variables that didn't exist before.
One of those is the fig object,
where if we check the type,
it is a matplotlib.figure,
and we see that here from whose magic command.
The second is the ax object, which again,
we see is an axes data type,
and we see the same thing if we call the type function.
The figure, think of it as
the picture frame that's containing everything,
the axes, where we actually place the data.