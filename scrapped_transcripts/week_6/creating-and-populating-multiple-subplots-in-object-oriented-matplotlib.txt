Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/ASO0I/creating-and-populating-multiple-subplots-in-object-oriented-matplotlib

English
The same approach,
Is used even if we want multiple axes or
literal subplots within a single figure,
Let's create two subplots, below Again,
I'll set it up the same way fig comma ax equals PLT subplots,
but now I'm not using the default argument to subplots I'm typing in two.
We get displayed to the screen that base set of axes
within the figure, that's why I like to again,
to think of this as the figure is the giant picture frame,
and you can have a collage or multiple pictures within the frame.
And that's exactly what's going on here,
if we again check the who's magic command,
fig is still a figure, but look at the ax object,
now it tells us it's actually a NumPy array.
There are two elements to this array,
which we're told here there's one dimension,
but if we now check the type of each element in the array,
we see each element is a matplotlib axis okay,
so what's, what's happening here?
By telling it make two subplots,
the two separate axes that will contain the data
are contained as elements in a NumPy array.
To access or get each axes,
we have to slice that NumPy array, so
even though we're graphing,
we are using NumPy slicing to support how
we will identify the particular subplot in our graphic,
We populate data or
plot the data by calling the method for
the corresponding axis element.
Now, what do I mean by that?
Well, ax zero is, as we have seen,
an axis object, every single axis,
as an object, has methods and attributes,
the plot method is a method for a matplotlib axis.
So let's plot that sine wave,
Calling that method does not show anything
it literally just tells us where the data were populated,
If I want to see the data, I need to display the figure,
because the axis is contained inside the figure,
the figure picture frame, we modified the 0th element,
which is the one panel in Matlab convention.
But because we're now using the actual python
style of object-oriented approach,
we are now back to the Pythonic zero-based index convention.
So if you really dislike how I was calling one instead of zero before,
this is further motivation for using the object-oriented, that way everything
is in fact completely consistent with graphing data and manipulating data.
How do we populate data, then on the other subplot,
we use the exact same approach.
We access the appropriate axis,
call its plotting method, and
populate the data accordingly, so
here again, I'm using the cosine wave.
And now if I display the figure object, you now see both facet or both subplots.
Have the plots accordingly, or, sorry, the data displayed accordingly.