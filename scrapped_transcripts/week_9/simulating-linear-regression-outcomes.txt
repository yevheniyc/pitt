Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/kjuBH/simulating-linear-regression-outcomes

English
What if we could replicate this process of
calling a random number generator over and over again?
Well, let's actually go ahead and do that.
Let's define a function which
calculates the trend for
a given set of intercept and slope,
and then generates random outputs
around the trend for a given standard deviation.
We will define a function named generate_lm_y,
having five input arguments to the function,
rid, xuse, b0, b1 Sigma_use.
Again, five arguments to the generate_lm_y function,
rid, xuse, b0, b1 Sigma_use.
I'll return to rid in a minute.
But the first action we're going to
do is to create a data frame,
which I'll name res_df for result.
It's a data frame where it has a key x and value xuse.
The user will be able to input values for x here.
Next, we need to calculate the trend,
and the trend is the intercept plus
the slope times the input.
In this function, I've named
my intercept b0 and
my slope b1 just to keep the variable names short.
But again, look at the function,
if you will, the relationship.
The average output or trend is
intercept plus slope times input.
Then we need to randomly generate the outputs.
Call our Gaussian random number generator,
where the average or location
is the trend and force it to be a NumPy array.
The scale is Sigma_use,
which is another argument to the function,
and the number of random numbers to
generate is the number of rows in our data frame.
Lastly, let's put in one more column,
rep_id, which is rid.
This is telling us how many
times we have called this entire process.
Think of it as a bookkeeping number.
Then we will return res_df.
Let's test it out.
Let's generate our initial, will call it,
the zero time for
our input x with my_intercept,
my_slope, and Sigma_noise.
I'm giving the input x as a Panda series.
My intercept and my slope and my defined Sigma_noise,
I'm getting out a data frame with
the true trend at each desired input value,
a randomly generated output value
and then a bookkeeping number,
how many times did I call the random number generator?
Let's replicate four times.
Study for list, create an initial empty list,
and now use a simple four loop for ix
in range 4, study_4_list.append generate_lm,
the zeroth argument is now the ix iterating variable.
The next argument, the input x from our data frame,
my_intercept, my_slope, and lastly, Sigma_noise.
Running this cell, we get a list of length 4.
Each element in the list is a data frame.
Each element in the list contains a separate action or
separate replication of calling
the random number generator around that average.
Vertically stack or combine the data frames in the list.
We'll name this result,
study_4_df = pd.concat study_4_list.
Let's put ignore_index equals true.
Study_4_df is now a data frame with many rows.
If we look at the head,
the zeroth rep_id,
let's look at the tail, the third rep_id.
We can now visualize the four random replications,
such as with a scatter plot of x and y,
where the column facets are rep_id.
The markers are a little hard to see,
so let's use the s argument to raise them in size, s=85.
This will make bigger markers.
Let me copy this code.
Now instead of using a scatter plot,
let's use kind equals line just to
make it easier on our eyes so that we
can see the wiggliness,
the randomness is different across the replications.
If we would instead put them all on a single axis,
x=x y=y, where the hue is
the rep_id and kind equals line.
We can now see we're getting
different behavior just as what we saw previously.
But what we really care about is the average output.
How is the average changing as the input changes.
Let's calculate the average output for
each unique value of the input.
We already know how to do that.
We can use a point plot
where x=x, y=y, kind equals point.