Source: https://www.coursera.org/learn/mds-introduction-to-data-centric-computing/lecture/Cf10j/preserving-index-and-identifying-unique-columns

English
Let's take a look at the little snapshot
of the reshaped or long format melted data.
Look at the last rows.
The index is in the thousands.
By default, we lose
the original index attribute when we melt,
meaning we lose which row the data originally came from.
We can keep the original index by
setting the ignore_index argument to false.
So if we take penguins_features.melt,
ignore_index and set it to false,
now look at the last index value is 344.
We now have every single row
identified by the index as we had originally.
So the zeroth index is the top row,
the zeroth row in the original data frame.
Look at the values in the zeroth row compared
to the zeroth index in
the reshaped data, the melted data.
However, I don't like the index attribute.
As I've said many times,
I prefer to convert the index attribute
into a regular column and rename it to rowid.
That way, it will act just like any other column.
So I'll take penguins_features and I'll reset the index.
I now have a column index.
But just to be safe,
I like to rename index to rowid.
That way, the name of the column does not
interfere with any attribute in the data frame.
Let's do this one more time
, penguins_features.reset_index(),
rename the column index to rowid.
Now, when I melt,
I cannot just melt.
However, we cannot melt with the default arguments.
We do not want to gather or stack
the rowid column with the other variables.
Instead, we need to specify that
the rowid column uniquely defines the row ID,
and this is done with the id_vars argument.
Now, id_vars, rowid is a regular column,
and then look at its values,
you can see 344.
Let me just copy this to speed things up.
Actually, let's do this.
We'll see it here in a second.
I'll name this lf. There we go.
Now I could do lf.loc [ lf.rowid == 0 ].
This is the original top row in penguins_features.
Here's the new index attribute,
here's the original rowid,
here's the columns, and here are the values.
Now, why am I bringing up this id_vars?
Well, remember,
the original penguins data frame had numeric columns.
It had those object columns.
So let's extract out those columns.
We'll name it into a new object, penguins_objects.
Penguins, let's select dtypes,
select the object, and force the deep copy.
We have now extracted out the three non-numeric columns.
Let's define a list that contains
the rowid column and the three object column names.
This list will therefore
hold all columns that uniquely define the row.
Because the row in the original data frame is
a row ID with
a given set of non-numeric value categories.
I'll name this id_cols = [ 'rowid' ] + penguins_objects,
the columns attribute, and force it to be a list.
Notice, I'm using the overloaded plus operator
to concatenate or combine two lists together.
So we're using the base
Python data manipulation tasks
from earlier in the semester.
Now, we can use id_cols to identify the columns to not
gather or stack when we
call the melt method on the original dataset.
Penguins.reset_index(), rename the column index
to rowid, melt id_vars as id_cols.
We have the 1,376 rows where we have associated,
with each of the original rows,
the combination of the
non-numerics with a numeric column and its value.